"""Tool base class"""

import inspect
import re
from abc import ABC, abstractmethod
from typing import Any, Callable, Dict, List, Optional, get_type_hints

from pydantic import BaseModel

class ToolParameter(BaseModel):
    name: str
    type: str
    description: str
    required: bool = True
    default: Any = None

def tool_action(name: str, description: str):
    """Decorator for tool action functions
    
    Usage:
        @tool_action(name="file_read", description="Read a file")
        def file_read(file_path: str) -> str:
            ...
    Args:
        name: Tool name
        description: Tool description
    """
    def decorator(func):
        func._is_tool_action = True
        func._tool_name = name
        func._tool_description = description
        return func
    return decorator

class Tool(ABC):
    def __init__(self, name: str, description: str, expandable: bool = False):
        """
        Initialize the tool.
        
        Args:
            name: Tool name
            description: Tool description
            expandable: Whether the tool can be expanded into multiple sub-tools
        """
        self.name = name
        self.description = description
        self.expandable = expandable
    
    @abstractmethod
    def run(self, parameters: dict[str, Any]) -> str:
        """Run the tool"""
        pass

    @abstractmethod
    def get_parameters(self) -> list[ToolParameter]:
        """Get the parameters for the tool"""
        pass

    def get_expanded_tools(self) -> Optional[list['Tool']]:
        """Get the expanded sub-tools if the tool is expandable
        
        Automatically generate sub-tools from methods decorated with @tool_action
        Subclasses can also override this method to provide custom expansion logic

        Returns:
            A list of sub-tools if the tool is expandable, otherwise None
        """
        if not self.expandable:
            return None
        
        # get tools from decorated methods
        sub_tools = []
        for _, method in inspect.getmembers(self, predicate=inspect.ismethod):
            if hasattr(method, "_is_tool_action") and method._is_tool_action:
                sub_tool = AutoGeneratedTool(
                    parent=self,
                    method=method,
                    name=method._tool_name,
                    description=method._tool_description,
                )
                sub_tools.append(sub_tool)

        return sub_tools if sub_tools else None


class AutoGeneratedTool(Tool):
    """Auto-generated tool - extracts parameters from method signature and docstring."""

    def __init__(
        self,
        parent: Tool,
        method: Callable,
        name: str = None,
        description: str = None,
    ):
        """Initialize the auto-generated tool.

        Args:
            parent (Tool): The parent tool
            method (Callable): The method to extract parameters from
            name (str): The name of the tool
            description (str): The description of the tool
        """
        self.parent = parent
        self.method = method

        if name is None:
            # If name is not provided, use the parent name and method name
            method_name = method.__name__.lstrip("_")
            name = f"{parent.name}_{method_name}"

        if description is None:
            description = self._extract_description_from_docstring()

        super().__init__(name=name, description=description, expandable=False)

        self._parameters = self._parse_parameters()

    def _extract_description_from_docstring(self) -> str:
        """Extract the description from the docstring"""
        doc = inspect.getdoc(self.method)
        if not doc:
            return f"Execute {self.method.__name__}"
        lines = doc.split("\n")
        for line in lines:
            line = line.strip()
            if line and not line.startswith("Args:") and not line.startswith("Returns:"):
                return line
        return f"Execute {self.method.__name__}"

    def _parse_parameters(self) -> List[ToolParameter]:
        """Parse the parameters from the method signature"""
        sig = inspect.signature(self.method)
        try:
            type_hints = get_type_hints(self.method)
        except Exception:
            type_hints = {}
        docstring = inspect.getdoc(self.method) or ""
        param_descriptions = self._parse_param_descriptions(docstring)

        parameters = []
        for param_name, param in sig.parameters.items():
            if param_name == "self":
                continue
            param_type_hint = type_hints.get(param_name, str)
            param_type = self._python_type_to_tool_type(param_type_hint)
            required = param.default == inspect.Parameter.empty
            default = None if required else param.default
            description = param_descriptions.get(param_name, f"Parameter {param_name}")

            parameters.append(
                ToolParameter(
                    name=param_name,
                    type=param_type,
                    description=description,
                    required=required,
                    default=default,
                )
            )
        return parameters

    def _parse_param_descriptions(self, docstring: str) -> Dict[str, str]:
        """Parse the parameter descriptions from the docstring"""
        descriptions = {}
        args_match = re.search(
            r"Args:\s*\n(.*?)(?:\n\s*\n|Returns:|$)", docstring, re.DOTALL
        )
        if not args_match:
            return descriptions
        args_section = args_match.group(1)
        param_pattern = r"^\s*(\w+)(?:\s*\([^)]+\))?\s*:\s*(.+?)(?=^\s*\w+\s*(?:\([^)]+\))?\s*:|$)"
        for match in re.finditer(param_pattern, args_section, re.MULTILINE | re.DOTALL):
            param_name = match.group(1).strip()
            param_desc = re.sub(r"\s+", " ", match.group(2).strip())
            descriptions[param_name] = param_desc
        return descriptions

    def _python_type_to_tool_type(self, py_type: type) -> str:
        """Convert the Python type to the tool type"""
        origin = getattr(py_type, "__origin__", None)
        if origin is not None:
            if origin is list:
                return "array"
            if origin is dict:
                return "object"
        type_map = {
            str: "string",
            int: "integer",
            float: "number",
            bool: "boolean",
            list: "array",
            dict: "object",
        }
        return type_map.get(py_type, "string")

    def get_parameters(self) -> List[ToolParameter]:
        """Get the parameters for the tool"""
        return self._parameters

    def run(self, parameters: Dict[str, Any]) -> str:
        """Run the tool"""
        result = self.method(**parameters)
        return result if isinstance(result, str) else str(result)
